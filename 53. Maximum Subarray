题目描述：
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
Example:
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.


思路：动态规划（DP）---O（n）
     分治法---O(nlogn)
     当遇到子数组或子字符串等“连续序列问题”时，子问题通常必须以当前元素结束，这样当下一个元素出现时，序列仍然是连续的
	/*
	 * DP过程：nums= {-2,1,-3,4,-1,2,1,-5,4}
	 * dp    [0]  [1]      [2]      [3]   [4]   [5]   [6]   [7]   [8] 
	 *       -2   -2<0,1   1>0,-2    4     3     5     6     1     5
	 *               dp[2]=nums[2]+dp[1]    
	 *         dp[1]=nums[1]+0     
	 * res   -2    1      1>-2,1     4     4     5     6     6     6    所以最终结果为6
	 */



实现：
    //直接DP    time:O(n)    space:O(n)
    public int maxSubArray(int[] nums){
        int[] dp=new int[nums.length];
        dp[0] = nums[0];
        int res = nums[0];
        
        for(int i=1;i<nums.length;i++){
            if(dp[i-1]>0){
                dp[i] = nums[i]+dp[i-1];
            }
            else{
                dp[i] = nums[i];
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }

    //仍使用DP的思想，但用一个变量代替dp[]数组     time:O(n)    space:O(1)  
    public int maxSubArray(int[] nums){
        int sum=nums[0];
        int res=nums[0];
        for(int i=1;i<nums.length;i++){
            sum=Math.max(nums[i],nums[i]+sum);
            res=Math.max(res,sum);
        }
        return res;
    }
