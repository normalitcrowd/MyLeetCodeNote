题目描述：
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 
    1
   / \
  2   2
 / \ / \
3  4 4  3

But the following [1,2,2,null,3,null,3] is not:
    1
   / \
  2   2
   \   \
   3    3



思路：递归
问题是只有一棵树时，递归表示比较麻烦（root.left.left...繁！）
所以可以再使用一个辅助函数来判断是否对称，参数是该树的左子树、右子树，，，然后思路就和判断两棵树是否一样类似了


实现：
//树结构定义
class TreeNode {
	      int val;
	      TreeNode left;
	      TreeNode right;
	      TreeNode(int x) { val = x; }
	  }
    
 //判断对称
  class SymmetricTree {
        //题目中给的函数
        public boolean isSymmetric(TreeNode root) {
         //异常情形---空树
         if(root==null) return true;
         return isMirror(root.left,root.right);
        }
      
      //自己定义的函数----递归
      public boolean isMirror(TreeNode l,TreeNode r){    //把左右子树作为参数
         //异常情形---空子树
         if(l==null && r==null) return true;
	       if(l==null || r==null) return false;
         
         if(l.val==r.val){
            return isMirror(l.left,r.right) && isMirror(l.right,r.left);  //对称位置进行比较！！！
         }
         else{
            return false;
         }
         
      }
      
  }
