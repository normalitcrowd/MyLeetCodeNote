题目描述：
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example: 
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4

思路：递归和非递归两种方式


实现：
//链表定义
class ListNode {   
		     int val;
		     ListNode next;
		     ListNode(int x) { val = x; }
		 }
//————————————————————递归实现
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
if(l1==null) return l2;
if(l2==null) return l1;

ListNode mergeList=null;  //定义合并后的链表为mergeList
if(l1.val<l2.val){   //若l1头结点比l2小
mergeList=l1;        //则把l1头结点赋给mergeList的头结点
mergeList.next=mergeTwoLists(l1.next,l2);  //  mergeList剩下的部分 需要  对l1剩下的部分 和 l2 继续合并
}
else{
mergeList=l2;
mergeList.next=mergeTwoLists(l1,l2.next);
}
return mergeList;   //最终l1,l2都进入mergeList了，合并完成
}

//—————————————————————非递归实现
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
if(l1==null) return l2;
if(l2==null) return l1;

ListNode mergeList=null;  //定义合并后的链表为mergeList
ListNode curList=null;
//确定mergeList / curList的头结点
if(l1.val<l2.val){
mergeList=l1;
l1=l1.next;
}
else{
mergeList=l2;
l2=l2.next;
}
curList=mergeList;
//确定curList剩下的结点 : curList.next
    //逐个比较l1,l2的头结点，小的就装进curList里，直到有空链表出现跳出循环
while(l1!=null && l2!=null){
if(l1.val<l2.val){
curList.next=l1;
l1=l1.next;
}
else{
curLIst.next=l2;
l2=l2.next;
}
curList=curList.next;
}

if(l1==null) curList.next=l2; //如果上面的循环中是l1先空的，就把l2剩下的全装进curList
if(l2==null) curList.next=l1;
return mergeList;
}

